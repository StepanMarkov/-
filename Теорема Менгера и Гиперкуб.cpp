//Докажите, что k-мерный гиперкуб k-связен с помощью теоремы Менгера.
//k-мерным гиперкубом называется граф, в котором вершины — битовые строки длины k, 
//а рёбра проведены между теми парами вершин, которые отличаются ровно в одном бите. 
//На вход подаётся две различные битовых строки A и B длины k через пробел.
//Выведите k простых путей в k-мерном гиперкубе из A в B, не пересекающихся по внутренним вершинам. 
//Формат вывода: один путь на строку; путь – последовательности битовых строк, разделённая пробелами.
//Автор: Марков С.А.

#include <iostream>
#include <string>
#include <list>
#include <vector>

using namespace std;

inline void flip(char& c) {
	c = (c == '0') ? '1' : '0';
}

int main() {

	string s1, s2, s;
	cin >> s1 >> s2;					//считываем данные
	list<size_t> index1, index2;				//вспомогательные контейнеры
	const size_t size(s1.size());				//размерность гиперкуба

	for (size_t i(0); i != size; ++i) {
		if (s1[i] == s2[i])				//если биты в двух строках равны
			index1.push_back(i);			//добавлем в первый контейнер
		else index2.push_back(i);			//иначе добавляем во второй
	}

	for (size_t j(0); j != index2.size(); ++j) {		//обработка второго контейнера
		s = s1;
		cout << s << ' ';				//выводим начало пути
		for (size_t& i : index2) {			//цикл по отличающимся битам
			flip(s[i]);				//инвертируем бит
			cout << s << ' ';			//выводим часть пути
		}
		cout << endl;					//вывод одного из путей завершен
		index2.push_back(index2.front());		//преобразуем контейнер, чтобы изменить
		index2.pop_front();				//правило обхода следующего пути (чтобы пути не пересекались)
	}

	for (size_t& j : index1) {				//обработка первого контейнера
		s = s1;
		cout << s << ' ';				//выводим начало пути
		flip(s[j]);					//инвертируем бит (биты в двух стоках s1 и s2 одинаковы)
		cout << s << ' ';				//нам нужно "отойти в сторону" чтобы провести непересекающиеся пути
		for (size_t& i : index2) {			//цикл по отличающимся битам битам
			flip(s[i]);
			cout << s << ' ';			//выводим путь
		}
		cout << s2 << ' ' << endl;			//выводим точку назначения
	}
}
